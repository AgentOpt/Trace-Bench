#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Autonomous LLM4AD task: optimization_p_median_capacitated
Generated by convert_llm4ad_benchmark.py

This is a fully self-contained task module that doesn't depend on the original LLM4AD codebase.
"""

# Embedded evaluation code (benchmark)
# References:
#   - Sun, W., Feng, S., Li, S., & Yang, Y. Co-bench: Benchmarking language
#       model agents in algorithm search for combinatorial optimization.
#       arXiv preprint arXiv:2504.04310 (2025).
#
# ------------------------------- Copyright --------------------------------
# Copyright (c) 2025 Optima Group.
#
# Permission is granted to use the LLM4AD platform for research purposes.
# All publications, software, or other works that utilize this platform
# or any part of its codebase must acknowledge the use of "LLM4AD" and
# cite the following reference:
#
# Fei Liu, Rui Zhang, Zhuoliang Xie, Rui Sun, Kai Li, Xi Lin, Zhenkun Wang,
# Zhichao Lu, and Qingfu Zhang, "LLM4AD: A Platform for Algorithm Design
# with Large Language Model," arXiv preprint arXiv:2412.17287 (2024).
#
# For inquiries regarding commercial use or licensing, please contact
# http://www.llm4ad.com/contact.html
# --------------------------------------------------------------------------

from __future__ import annotations

from typing import Any
import numpy as np
from llm4ad_loader import Evaluation
from llm4ad_loader import load_subdir_as_text
# from llm4ad.task.optimization.co_bench.utils import load_subdir_as_text  # Common utilities from llm4ad_loader
# from llm4ad.task.optimization.co_bench.p_median_capacitated_co_bench.template import template_program, task_description  # Template values embedded below

# Embedded template values
template_program = 'import numpy as np\nimport scipy.optimize as opt\nimport math\nimport random\nfrom typing import List, Tuple, Dict\ndef solve(best_known: float, n: int, p: int, Q: float, customers: list) -> dict:\n    """\n    Solve the Capacitated P-Median Problem.\n    This function receives the data for one problem instance via keyword arguments:\n      - best_known (float): Best known solution value for reference.\n      - n (int): Number of customers.\n      - p (int): Number of medians to choose.\n      - Q (float): Capacity limit for each median.\n      - customers (list of tuples): Each tuple is (customer_id, x, y, demand).\n    The goal is to select p medians (from the customers) and assign every customer to one\n    of these medians so that the total cost is minimized. The cost for a customer is the\n    Euclidean distance (rounded down to the nearest integer) to its assigned median, and the\n    total demand assigned to each median must not exceed Q.\n    Evaluation Metric:\n      The solution is evaluated by computing the ratio:\n          score = best_known / computed_total_cost,\n      where computed_total_cost is the sum over all customers of the (floored) Euclidean distance\n      to its assigned median.\n    Note: This is a placeholder function. Replace the placeholder with an actual algorithm.\n    Returns:\n      A dictionary with the following keys:\n        - \'objective\': (numeric) the total cost (objective value) computed by the algorithm.\n        - \'medians\': (list of int) exactly p customer IDs chosen as medians.\n        - \'assignments\': (list of int) a list of n integers, where the i-th integer is the customer\n                         ID (from the chosen medians) assigned to customer i.\n    """\n    # Placeholder: Replace this with your actual implementation.\n    # For now, we return an empty solution structure.\n    return {\n        "objective": 0,  # total cost (to be computed)\n        "medians": [],  # list of p medians (customer IDs)\n        "assignments": []  # list of n assignments (each is one of the medians)\n    }'
task_description = '("The Capacitated P-Median Problem is a facility location optimization problem where the objective "'


__all__ = ['PMCEvaluationCB']


class PMCEvaluationCB(Evaluation):

    def __init__(self,
                 timeout_seconds=50,
                 **kwargs):

        """
            Args:
                None
            Raises:
                AttributeError: If the data key does not exist.
                FileNotFoundError: If the specified data file is not found.
        """

        super().__init__(
            template_program=template_program,
            task_description=task_description,
            use_numba_accelerate=False,
            timeout_seconds=timeout_seconds
        )

        # Load datasets from Hugging Face
        dataset = load_subdir_as_text("CO-Bench/CO-Bench", "p-median - capacitated")
        self._datasets = {}
        for filename in dataset:
            # Join all text rows into a single string
            text_content = '\n'.join([row['text'] for row in dataset[filename]])
            self._datasets[filename] = text_content

    def evaluate_program(self, program_str: str, callable_func: callable, **kwargs) -> Any | None:
        return self.evaluate(callable_func)

    def evaluate(self, eva: callable) -> float | None:
        ins_cases = []
        for case_id, ins in enumerate(self._datasets.values()):
            ins_cases.append(self.load_data(ins))

        fitness_list = []
        try:
            for i in ins_cases:
                for j in i:
                    result = eva(j['best_known'], j['n'], j['p'], j['Q'], j['customers'])
                    fitness = self.eval_func(best_known=j['best_known'], n=j['n'], p=j['p'], Q=j['Q'], customers=j['customers'], objective=result['objective'], medians=result['medians'], assignments=result['assignments'])
                    fitness_list.append(fitness)

            return -np.mean(fitness_list)

        except ValueError as e:
            print(e)
            return None

    def load_data(self, input_string):
        """
        Load one or more instances of the Capacitated P-Median Problem from a text file.
        The input file structure is:
          Line 1: An integer M, the number of problem instances in the file.
          Then, for each instance:
              - A header line with two values: <problem_number> <best_known_solution_value>
              - A line with three values: <n> <p> <Q>
              - n subsequent lines each with: <customer_number> <x_coordinate> <y_coordinate> <demand>
        Returns:
          A list of dictionaries. Each dictionary contains the keys:
             - 'best_known': float
             - 'n': int
             - 'p': int
             - 'Q': float
             - 'customers': list of tuples (customer_id, x, y, demand)
        """
        cases = []
        try:
            lines = [line.strip() for line in input_string.split('\n') if line.strip() != '']
        except Exception as e:
            raise ValueError("Error reading input file: " + str(e))

        if not lines:
            raise ValueError("Input file is empty.")

        try:
            M = int(lines[0])
        except Exception as e:
            raise ValueError("The first line must be an integer representing the number of cases.")

        index = 1
        for case_idx in range(M):
            if index >= len(lines):
                raise ValueError("Unexpected end of file when reading case {}.".format(case_idx + 1))

            # Read problem header: <problem_number> <best_known_solution_value>
            tokens = lines[index].split()
            if len(tokens) < 2:
                raise ValueError("Invalid problem header at case {}.".format(case_idx + 1))
            try:
                # We don't need the problem number, so we can ignore it.
                _ = int(tokens[0])
                best_known = float(tokens[1])
            except Exception as e:
                raise ValueError("Error parsing problem header at case {}: {}".format(case_idx + 1, e))
            index += 1

            if index >= len(lines):
                raise ValueError("Missing instance parameters for case {}.".format(case_idx + 1))

            # Read instance parameters: <n> <p> <Q>
            tokens = lines[index].split()
            if len(tokens) < 3:
                raise ValueError("Invalid instance parameters at case {}.".format(case_idx + 1))
            try:
                n = int(tokens[0])
                p = int(tokens[1])
                Q = float(tokens[2])
            except Exception as e:
                raise ValueError("Error parsing instance parameters at case {}: {}".format(case_idx + 1, e))
            index += 1

            # Read n customer lines
            customers = []
            if len(lines) < index + n:
                raise ValueError("Expected {} customer lines for case {}, but found fewer.".format(n, case_idx + 1))
            for i in range(n):
                tokens = lines[index].split()
                if len(tokens) < 4:
                    raise ValueError("Invalid customer data at line {} in case {}.".format(index + 1, case_idx + 1))
                try:
                    customer_id = int(tokens[0])
                    x = float(tokens[1])
                    y = float(tokens[2])
                    demand = float(tokens[3])
                except Exception as e:
                    raise ValueError(
                        "Error parsing customer data on line {} in case {}: {}".format(index + 1, case_idx + 1, e))
                customers.append((customer_id, x, y, demand))
                index += 1

            case_data = {
                "best_known": best_known,
                "n": n,
                "p": p,
                "Q": Q,
                "customers": customers
            }
            cases.append(case_data)

        return cases

    def eval_func(self, **kwargs):
        """
        Evaluate the solution for a single instance of the Capacitated P-Median Problem.
        This function expects the following keyword arguments (combined from the instance data and the solution):
          - best_known (float): Best known solution value (for reference).
          - n (int): Number of customers.
          - p (int): Number of medians.
          - Q (float): Capacity of each median.
          - customers (list of tuples): Each tuple is (customer_id, x, y, demand).
          - objective (numeric): The objective value (total cost) reported by the solution.
          - medians (list of int): List of chosen medians (customer IDs), exactly p elements.
          - assignments (list of int): List of assignments for each customer (length n), where each entry is one of the chosen medians.
        The evaluation performs the following:
          1. Verifies that each assignment is to one of the selected medians.
          2. Checks that the total demand assigned to each median does not exceed Q.
          3. Recomputes the total cost as the sum, over all customers, of the Euclidean distance (rounded down)
             from the customer to its assigned median.
          4. Computes the score as: score = best_known / computed_total_cost.
        Returns:
          A scalar float representing the score for the solution.
        """
        import math

        # Extract instance data
        best_known = kwargs.get("best_known")
        n = kwargs.get("n")
        p = kwargs.get("p")
        Q = kwargs.get("Q")
        customers = kwargs.get("customers")

        # Extract solution data
        reported_obj = kwargs.get("objective")
        medians = kwargs.get("medians")
        assignments = kwargs.get("assignments")

        if best_known is None or n is None or p is None or Q is None or customers is None:
            raise ValueError("Instance data is incomplete.")
        if reported_obj is None or medians is None or assignments is None:
            raise ValueError("Solution data is incomplete.")

        # Validate medians length
        if len(medians) != p:
            raise ValueError("The solution must contain exactly {} medians; found {}.".format(p, len(medians)))

        # Validate assignments length
        if len(assignments) != n:
            raise ValueError("The solution must contain exactly {} assignments; found {}.".format(n, len(assignments)))

        # Build a dictionary for quick lookup of customer data by customer_id.
        cust_dict = {}
        for cust in customers:
            cid, x, y, demand = cust
            cust_dict[cid] = (x, y, demand)

        # Verify that each median is a valid customer.
        for m in medians:
            if m not in cust_dict:
                raise ValueError("Median {} is not found in the customer data.".format(m))

        # Verify that each customer's assignment is one of the selected medians.
        for idx, a in enumerate(assignments):
            if a not in medians:
                raise ValueError(
                    "Customer {} is assigned to {} which is not in the list of selected medians.".format(idx + 1, a))

        # Check capacity constraints.
        capacity_usage = {m: 0.0 for m in medians}
        for i, a in enumerate(assignments):
            # Assuming that the order of customers in 'customers' corresponds to customer 1..n.
            demand = customers[i][3]
            capacity_usage[a] += demand
        for m, used in capacity_usage.items():
            if used > Q + 1e-6:  # small tolerance
                raise ValueError(
                    "Capacity exceeded for median {}: used capacity {:.4f} exceeds allowed capacity {:.4f}.".format(m,
                                                                                                                    used,
                                                                                                                    Q))

        # Recompute the total cost.
        total_cost = 0
        for i, a in enumerate(assignments):
            # Get customer i data.
            try:
                cid, cx, cy, _ = customers[i]
            except Exception as e:
                raise ValueError("Error accessing data for customer {}: {}".format(i + 1, e))
            # Get the assigned median's coordinates.
            if a not in cust_dict:
                raise ValueError("Assigned median {} for customer {} not found.".format(a, i + 1))
            mx, my, _ = cust_dict[a]
            d = math.sqrt((cx - mx) ** 2 + (cy - my) ** 2)
            total_cost += math.floor(d)

        if total_cost <= 0:
            raise ValueError("Computed total cost is non-positive, which is invalid.")

        score = best_known / total_cost
        return score

    def get_dev(self):
        dev = {'pmedcap1.txt': [3, 11, 16, 0, 4, 2, 1, 9, 19, 18]}

        return dev






# Task configuration for benchmark task
ENTRY_NAME = 'solve'
FUNCTION_SIGNATURE = 'def solve(...):'
IMPORT_HEADER = 'import numpy as np\nimport scipy.optimize as opt\nimport math\nimport random\nfrom typing import List, Tuple, Dict'
TASK_DESCRIPTION = '("The Capacitated P-Median Problem is a facility location optimization problem where the objective "'
OBJECTIVE_TEXT = 'You are optimizing the implementation of `solve` for the LLM4AD task.\\n\\nTask description:\\n("The Capacitated P-Median Problem is a facility location optimization problem where the objective "\\n\\nYour goal is to return a correct and efficient function whose score (computed by the task evaluator) is as high as possible.'
TEMPLATE_FUNCTION = 'import numpy as np\nimport scipy.optimize as opt\nimport math\nimport random\nfrom typing import List, Tuple, Dict\ndef solve(best_known: float, n: int, p: int, Q: float, customers: list) -> dict:\n    """\n    Solve the Capacitated P-Median Problem.\n    This function receives the data for one problem instance via keyword arguments:\n      - best_known (float): Best known solution value for reference.\n      - n (int): Number of customers.\n      - p (int): Number of medians to choose.\n      - Q (float): Capacity limit for each median.\n      - customers (list of tuples): Each tuple is (customer_id, x, y, demand).\n    The goal is to select p medians (from the customers) and assign every customer to one\n    of these medians so that the total cost is minimized. The cost for a customer is the\n    Euclidean distance (rounded down to the nearest integer) to its assigned median, and the\n    total demand assigned to each median must not exceed Q.\n    Evaluation Metric:\n      The solution is evaluated by computing the ratio:\n          score = best_known / computed_total_cost,\n      where computed_total_cost is the sum over all customers of the (floored) Euclidean distance\n      to its assigned median.\n    Note: This is a placeholder function. Replace the placeholder with an actual algorithm.\n    Returns:\n      A dictionary with the following keys:\n        - \'objective\': (numeric) the total cost (objective value) computed by the algorithm.\n        - \'medians\': (list of int) exactly p customer IDs chosen as medians.\n        - \'assignments\': (list of int) a list of n integers, where the i-th integer is the customer\n                         ID (from the chosen medians) assigned to customer i.\n    """\n    # Placeholder: Replace this with your actual implementation.\n    # For now, we return an empty solution structure.\n    return {\n        "objective": 0,  # total cost (to be computed)\n        "medians": [],  # list of p medians (customer IDs)\n        "assignments": []  # list of n assignments (each is one of the medians)\n    }'
EVAL_CLASS_NAME = 'PMCEvaluationCB'
EVAL_KWARGS = {'timeout_seconds': 60}

def build_trace_problem(**override_eval_kwargs) -> dict:
    """Build a Trace-ready problem using embedded benchmark evaluator."""
    
    # Create evaluator instance with embedded class
    eval_kwargs_final = EVAL_KWARGS.copy()
    eval_kwargs_final.update(override_eval_kwargs)
    
    evaluator = globals()[EVAL_CLASS_NAME](**eval_kwargs_final)
    
    from llm4ad_loader import AutonomousEvaluatorGuide
    from opto import trace
    
    # Create parameter
    initial_code = TEMPLATE_FUNCTION.strip()
    param = trace.node(initial_code, name='__code', 
                      description=f'The code should start with: {FUNCTION_SIGNATURE}', 
                      trainable=True)
    
    # Create guide using benchmark embedded evaluator
    guide = AutonomousEvaluatorGuide(evaluator, ENTRY_NAME, IMPORT_HEADER, 
                                   timeout=eval_kwargs_final.get('timeout_seconds', 30))
    
    # Create dataset
    train_dataset = dict(
        inputs=[TASK_DESCRIPTION],
        infos=[{'imports': IMPORT_HEADER, 'entry': ENTRY_NAME}]
    )
    
    # Optimizer kwargs
    optimizer_kwargs = dict(
        objective=OBJECTIVE_TEXT,
        memory_size=10
    )
    
    return dict(
        param=param,
        guide=guide,
        train_dataset=train_dataset,
        optimizer_kwargs=optimizer_kwargs,
        metadata=dict(
            entry=ENTRY_NAME,
            function_signature=FUNCTION_SIGNATURE,
            eval_class=EVAL_CLASS_NAME,
            benchmark=True,
        )
    )
