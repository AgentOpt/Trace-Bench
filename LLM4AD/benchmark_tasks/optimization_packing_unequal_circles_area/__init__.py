#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Autonomous LLM4AD task: optimization_packing_unequal_circles_area
Generated by convert_llm4ad_benchmark.py

This is a fully self-contained task module that doesn't depend on the original LLM4AD codebase.
"""

# Embedded evaluation code (benchmark)
# References:
#   - Sun, W., Feng, S., Li, S., & Yang, Y. Co-bench: Benchmarking language
#       model agents in algorithm search for combinatorial optimization.
#       arXiv preprint arXiv:2504.04310 (2025).
#
# ------------------------------- Copyright --------------------------------
# Copyright (c) 2025 Optima Group.
#
# Permission is granted to use the LLM4AD platform for research purposes.
# All publications, software, or other works that utilize this platform
# or any part of its codebase must acknowledge the use of "LLM4AD" and
# cite the following reference:
#
# Fei Liu, Rui Zhang, Zhuoliang Xie, Rui Sun, Kai Li, Xi Lin, Zhenkun Wang,
# Zhichao Lu, and Qingfu Zhang, "LLM4AD: A Platform for Algorithm Design
# with Large Language Model," arXiv preprint arXiv:2412.17287 (2024).
#
# For inquiries regarding commercial use or licensing, please contact
# http://www.llm4ad.com/contact.html
# --------------------------------------------------------------------------

from __future__ import annotations

from typing import Any
import numpy as np
from llm4ad_loader import Evaluation
from llm4ad_loader import load_subdir_as_text
# from llm4ad.task.optimization.co_bench.utils import load_subdir_as_text  # Common utilities from llm4ad_loader
# from llm4ad.task.optimization.co_bench.packing_unequal_circles_area_co_bench.template import template_program, task_description  # Template values embedded below

# Embedded template values
template_program = 'import numpy as np\nimport scipy.optimize as opt\nimport math\nimport random\nfrom typing import List, Tuple, Dict\ndef solve(n:int, cx: float, cy: float, R: float, radii: list) -> dict:\n    """\n    Solve the Unequal Circle Packing problem (Maximize Area version).\n    Problem Description:\n      Given a circular container with center (cx, cy) and radius R, and n circles\n      with specified radii (provided in \'radii\'), decide which circles to pack and\n      determine the centers (x_i, y_i) for the packed circles such that:\n      1. Containment: Each packed circle i must lie completely within the container.\n         (x_i - cx)^2 + (y_i - cy)^2 <= α_i * (R - radii[i])^2,  for i = 1,...,n.\n         (If α_i = 0, then the circle is not packed and its center is set to (cx, cy).)\n      2. Non-Overlap: For every pair of circles i and j (with i < j), if both are packed,\n         their centers must satisfy:\n         (x_i - x_j)^2 + (y_i - y_j)^2 >= ( (α_i + α_j - 1) * (radii[i] + radii[j]) )^2.\n         (This is a linearized version of the product α_i * α_j used in the paper.)\n      3. Binary decisions: α_i ∈ {0, 1} for i = 1,...,n, where α_i = 1 indicates circle i is packed.\n         (For circles not packed, we force (x_i, y_i) to equal (cx, cy).)\n      4. Objective: Maximize the total area of the circles packed:\n         maximize sum_{i=1}^n α_i * (pi * radii[i]^2).\n    Input kwargs:\n      - n     : int, the number of circles.\n      - cx    : float, x-coordinate of the container\'s center.\n      - cy    : float, y-coordinate of the container\'s center.\n      - R     : float, the radius of the container.\n      - radii : list of float, each element is the radius of a circle.\n    Returns:\n      A dictionary with one key:\n        - "coords": a list of n (x, y) tuples corresponding to the centers of the circles.\n                    For circles not packed (α_i = 0), (x, y) should be (-1, -1).\n    """\n    # ===== Placeholder Implementation =====\n\n    return {"coords": []}'
task_description = '("The problem involves packing a subset of unequal circles into a fixed circular container with "'


__all__ = ['PUCAEvaluationCB']


class PUCAEvaluationCB(Evaluation):

    def __init__(self,
                 timeout_seconds=50,
                 **kwargs):

        """
            Args:
                None
            Raises:
                AttributeError: If the data key does not exist.
                FileNotFoundError: If the specified data file is not found.
        """

        super().__init__(
            template_program=template_program,
            task_description=task_description,
            use_numba_accelerate=False,
            timeout_seconds=timeout_seconds
        )

        # Load datasets from Hugging Face
        dataset = load_subdir_as_text("CO-Bench/CO-Bench", "Packing unequal circles area")
        self._datasets = {}
        for filename in dataset:
            # Join all text rows into a single string
            text_content = '\n'.join([row['text'] for row in dataset[filename]])
            self._datasets[filename] = text_content

    def evaluate_program(self, program_str: str, callable_func: callable, **kwargs) -> Any | None:
        return self.evaluate(callable_func)

    def evaluate(self, eva: callable) -> float | None:
        ins_cases = []
        for case_id, ins in enumerate(self._datasets.values()):
            ins_cases.append(self.load_data(ins))

        fitness_list = []
        try:
            for i in ins_cases:
                for j in i:
                    result = eva(j['n'], j['cx'], j['cy'], j['R'], j['radii'])
                    fitness = self.eval_func(n=j['n'], cx=j['cx'], cy=j['cy'], R=j['R'], radii=j['radii'], coords=result['coords'])
                    fitness_list.append(fitness)

            return np.mean(fitness_list)

        except ValueError as e:
            print(e)
            return None

    def load_data(self, input_string):
        """
        Load and parse the input file containing one or multiple cases.
        File Format:
          - The file is a plain-text file with non-empty lines.
          - Each case starts with a header line containing exactly four numbers:
                n cx cy R
            where:
              • n  is the number of circles (an integer),
              • cx and cy are the container's center coordinates (floats),
              • R  is the container's radius (float).
          - The next n non-empty lines each contain one real number representing
            the radius of a circle.
        Returns:
          A list of cases, where each case is a dictionary with keys:
              "n"     : int, number of circles.
              "cx"    : float, container center x-coordinate.
              "cy"    : float, container center y-coordinate.
              "R"     : float, container radius.
              "radii" : list of float, the radii of the circles.
        """
        cases = []
        try:
            lines = [line.strip() for line in input_string.split('\n') if line.strip() != '']
        except Exception as e:
            raise Exception(f"Error reading input file: {e}")

        i = 0
        total_lines = len(lines)
        while i < total_lines:
            header_tokens = lines[i].split()
            if len(header_tokens) != 4:
                raise Exception(f"Header line at line {i + 1} must contain exactly 4 numbers: n cx cy R.")
            try:
                n = int(header_tokens[0])
                cx = float(header_tokens[1])
                cy = float(header_tokens[2])
                R = float(header_tokens[3])
            except Exception as e:
                raise Exception(f"Error parsing header on line {i + 1}: {e}")

            if i + n >= total_lines:
                raise Exception(f"Not enough lines for {n} circle radii after line {i + 1}.")
            radii = []
            for j in range(1, n + 1):
                try:
                    # Even if there are extra tokens, take the first as the radius.
                    r = float(lines[i + j].split()[0])
                    radii.append(r)
                except Exception as e:
                    raise Exception(f"Error parsing circle radius on line {i + j + 1}: {e}")
            case = {"n": n, "cx": cx, "cy": cy, "R": R, "radii": radii}
            cases.append(case)
            i += n + 1  # Move to the next case header (if any)
        return cases

    def eval_func(self, **kwargs):
        """
        Evaluate the solution for the Maximise Area problem of Unequal Circle Packing.
        Input (merged from the case data and the solution):
          - n     : int, the total number of circles.
          - cx    : float, x-coordinate of the container's center.
          - cy    : float, y-coordinate of the container's center.
          - R     : float, the container's radius.
          - radii : list of float, radii for each circle.
          - coords: list of (x, y) tuples, the centers of the circles as produced by solve.
                    A circle is considered unpacked if its center equals (-1, -1) (within tolerance).
        Evaluation Details:
          1. Identify packed circles: a circle is considered packed if its center is not (-1, -1)
             (within a small tolerance tol).
          2. For every packed circle:
             - Verify container feasibility:
                 Ensure that sqrt((x - cx)^2 + (y - cy)^2) + r_i <= R (within tolerance).
             - Record its container clearance: clearance = R - (distance from (cx, cy) + r_i).
          3. For every pair of packed circles, verify non-overlap:
                 Ensure that the distance between centers >= r_i + r_j (within tolerance).
             And record the pair clearance: (distance - (r_i + r_j)).
          4. If any feasibility constraint is violated (beyond tol), raise an Exception.
          5. Compute the primary score as the total area of packed circles:
                 total_area = sum(π * (r_i)^2 for each packed circle).
             Then, use the minimum clearance (across all container and pair clearances) as a tie-breaker.
             (For example, final score = total_area + ε * (minimum clearance), with ε small.)
          6. Return the final score (a higher score indicates a better solution).
        Returns:
          float: the evaluation score.
        """
        import math

        tol = 1e-5  # Numerical tolerance.

        # Extract required inputs.
        try:
            n = kwargs["n"]
            cx = kwargs["cx"]
            cy = kwargs["cy"]
            container_R = kwargs["R"]
            radii = kwargs["radii"]
            coords = kwargs["coords"]
        except KeyError as e:
            raise Exception(f"Missing required parameter: {e}")

        if len(coords) != n:
            raise Exception(f"Expected {n} coordinates, but got {len(coords)}.")

        # Identify packed circles.
        # Convention: a circle is considered not packed if its center equals (-1, -1) within tolerance.
        packed_indices = []
        for i in range(n):
            x, y = coords[i]
            if not (abs(x + 1) <= tol and abs(y + 1) <= tol):
                packed_indices.append(i)

        # Evaluate feasibility for each packed circle (container constraint).
        container_clearances = []
        for i in packed_indices:
            x, y = coords[i]
            r = radii[i]
            dist = math.hypot(x - cx, y - cy)
            clearance = container_R - (dist + r)
            if clearance < -tol:
                raise Exception(f"Circle {i} violates container constraint by {-clearance}.")
            container_clearances.append(clearance)

        # Evaluate non-overlap feasibility for every pair of packed circles.
        pair_clearances = []
        for idx, i in enumerate(packed_indices):
            for j in packed_indices[idx + 1:]:
                x1, y1 = coords[i]
                x2, y2 = coords[j]
                center_distance = math.hypot(x1 - x2, y1 - y2)
                required_distance = radii[i] + radii[j]
                clearance = center_distance - required_distance
                if clearance < -tol:
                    raise Exception(f"Circles {i} and {j} overlap by {-clearance}.")
                pair_clearances.append(clearance)

        # Primary measure: total area of packed circles.
        total_area = 0.0
        for i in packed_indices:
            total_area += math.pi * (radii[i] ** 2)

        # Final score: primary is the total area packed
        score = total_area
        return score

    def norm_score(self, results):
        optimal_scores = {
            "circle1.txt": [197.0718],
            "circle2.txt": [290.5062],
            "circle3.txt": [502.0171],
            "circle4.txt": [642.9087],
        }

        normed = {}
        for case, (scores, error_message) in results.items():
            if case not in optimal_scores:
                continue  # Skip if there's no optimal score defined.
            optimal_list = optimal_scores[case]
            normed_scores = []
            # Compute normalized score for each index.
            for idx, score in enumerate(scores):
                if isinstance(score, (int, float)):
                    normed_scores.append(score / optimal_list[idx])
                else:
                    normed_scores.append(score)
            normed[case] = (normed_scores, error_message)
        return normed

    def get_dev(self):
        dev = {'circle1.txt': [], 'circle2.txt': [], 'circle3.txt': [], 'circle4.txt': []}

        return dev







# Task configuration for benchmark task
ENTRY_NAME = 'solve'
FUNCTION_SIGNATURE = 'def solve(...):'
IMPORT_HEADER = 'import numpy as np\nimport scipy.optimize as opt\nimport math\nimport random\nfrom typing import List, Tuple, Dict'
TASK_DESCRIPTION = '("The problem involves packing a subset of unequal circles into a fixed circular container with "'
OBJECTIVE_TEXT = 'You are optimizing the implementation of `solve` for the LLM4AD task.\\n\\nTask description:\\n("The problem involves packing a subset of unequal circles into a fixed circular container with "\\n\\nYour goal is to return a correct and efficient function whose score (computed by the task evaluator) is as high as possible.'
TEMPLATE_FUNCTION = 'import numpy as np\nimport scipy.optimize as opt\nimport math\nimport random\nfrom typing import List, Tuple, Dict\ndef solve(n:int, cx: float, cy: float, R: float, radii: list) -> dict:\n    """\n    Solve the Unequal Circle Packing problem (Maximize Area version).\n    Problem Description:\n      Given a circular container with center (cx, cy) and radius R, and n circles\n      with specified radii (provided in \'radii\'), decide which circles to pack and\n      determine the centers (x_i, y_i) for the packed circles such that:\n      1. Containment: Each packed circle i must lie completely within the container.\n         (x_i - cx)^2 + (y_i - cy)^2 <= α_i * (R - radii[i])^2,  for i = 1,...,n.\n         (If α_i = 0, then the circle is not packed and its center is set to (cx, cy).)\n      2. Non-Overlap: For every pair of circles i and j (with i < j), if both are packed,\n         their centers must satisfy:\n         (x_i - x_j)^2 + (y_i - y_j)^2 >= ( (α_i + α_j - 1) * (radii[i] + radii[j]) )^2.\n         (This is a linearized version of the product α_i * α_j used in the paper.)\n      3. Binary decisions: α_i ∈ {0, 1} for i = 1,...,n, where α_i = 1 indicates circle i is packed.\n         (For circles not packed, we force (x_i, y_i) to equal (cx, cy).)\n      4. Objective: Maximize the total area of the circles packed:\n         maximize sum_{i=1}^n α_i * (pi * radii[i]^2).\n    Input kwargs:\n      - n     : int, the number of circles.\n      - cx    : float, x-coordinate of the container\'s center.\n      - cy    : float, y-coordinate of the container\'s center.\n      - R     : float, the radius of the container.\n      - radii : list of float, each element is the radius of a circle.\n    Returns:\n      A dictionary with one key:\n        - "coords": a list of n (x, y) tuples corresponding to the centers of the circles.\n                    For circles not packed (α_i = 0), (x, y) should be (-1, -1).\n    """\n    # ===== Placeholder Implementation =====\n\n    return {"coords": []}'
EVAL_CLASS_NAME = 'PUCAEvaluationCB'
EVAL_KWARGS = {'timeout_seconds': 60}

def build_trace_problem(**override_eval_kwargs) -> dict:
    """Build a Trace-ready problem using embedded benchmark evaluator."""
    
    # Create evaluator instance with embedded class
    eval_kwargs_final = EVAL_KWARGS.copy()
    eval_kwargs_final.update(override_eval_kwargs)
    
    evaluator = globals()[EVAL_CLASS_NAME](**eval_kwargs_final)
    
    from llm4ad_loader import AutonomousEvaluatorGuide
    from opto import trace
    
    # Create parameter
    initial_code = TEMPLATE_FUNCTION.strip()
    param = trace.node(initial_code, name='__code', 
                      description=f'The code should start with: {FUNCTION_SIGNATURE}', 
                      trainable=True)
    
    # Create guide using benchmark embedded evaluator
    guide = AutonomousEvaluatorGuide(evaluator, ENTRY_NAME, IMPORT_HEADER, 
                                   timeout=eval_kwargs_final.get('timeout_seconds', 30))
    
    # Create dataset
    train_dataset = dict(
        inputs=[TASK_DESCRIPTION],
        infos=[{'imports': IMPORT_HEADER, 'entry': ENTRY_NAME}]
    )
    
    # Optimizer kwargs
    optimizer_kwargs = dict(
        objective=OBJECTIVE_TEXT,
        memory_size=10
    )
    
    return dict(
        param=param,
        guide=guide,
        train_dataset=train_dataset,
        optimizer_kwargs=optimizer_kwargs,
        metadata=dict(
            entry=ENTRY_NAME,
            function_signature=FUNCTION_SIGNATURE,
            eval_class=EVAL_CLASS_NAME,
            benchmark=True,
        )
    )
