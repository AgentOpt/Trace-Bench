#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Autonomous LLM4AD task: optimization_tsp_gls_2O
Generated by convert_llm4ad_benchmark.py

This is a fully self-contained task module that doesn't depend on the original LLM4AD codebase.
"""

# Embedded evaluation code (benchmark)
# name: str: TSP_GLS_2O_Evaluation
# Parameters:
# timeout_seconds: int: 20
# end
from __future__ import annotations

from typing import Tuple, Any
import numpy as np
from llm4ad_loader import Evaluation
import os, sys
sys.path.insert(0, os.path.dirname(__file__))
from get_instance import GetData, TSPInstance
# from llm4ad.task.optimization.tsp_gls_2O.get_instance import GetData, TSPInstance  # Converted from LLM4AD import
# from llm4ad.task.optimization.tsp_gls_2O.template import template_program, task_description  # Template values embedded below

# Embedded template values
template_program = 'import numpy as np\ndef update_edge_distance(edge_distance: np.ndarray, local_opt_tour: np.ndarray, edge_n_used: np.ndarray) -> np.ndarray:\n    """\n    Design a novel algorithm to update the distance matrix.\n\n    Args:\n    edge_distance: A matrix of the distance.\n    local_opt_tour: An array of the local optimal tour of IDs.\n    edge_n_used: A matrix of the number of each edge used during permutation.\n\n    Return:\n    updated_edge_distance: A matrix of the updated distance.\n    """\n    updated_edge_distance = np.copy(edge_distance)\n\n    # Calculate combined importance and frequency factor\n    combined_factor = (1 / edge_n_used) + (1 / edge_n_used)\n\n    for i in range(len(local_opt_tour) - 1):\n        node1 = local_opt_tour[i]\n        node2 = local_opt_tour[i + 1]\n\n        update_factor = combined_factor[node1, node2]\n\n        updated_edge_distance[node1, node2] += update_factor\n        updated_edge_distance[node2, node1] = updated_edge_distance[node1, node2]\n\n    return updated_edge_distance'
task_description = 'Given an edge distance matrix and a local optimal route, please help me design a strategy to update the distance matrix to avoid being trapped in the local optimum with the final goal of finding a tour with minimized distance. You should create a heuristic for me to update the edge distance matrix.'

from .gls import guided_local_search_with_time

__all__ = ['TSP_GLS_2O_Evaluation']

perturbation_moves = 5
iter_limit = 1000


def calculate_cost(inst: TSPInstance, path: np.ndarray) -> float:
    # assert (np.sort(path) == np.arange(inst.n)).all(), 'Illegal path'
    return inst.distmat[path, np.roll(path, 1)].sum().item()

def solve_with_time(inst: TSPInstance, eva) -> Tuple[float, float]:
    try:
        result, running_time = guided_local_search_with_time(inst.distmat, inst.distmat.copy(), eva, perturbation_moves, iter_limit)
        cost = calculate_cost(inst, result)
    except Exception as e:
        # cost, running_time = 1E10, 1E10
        cost, running_time = float("inf"), float("inf")
    # print(result)
    return cost, running_time

def evaluate(instance_data,n_ins,prob_size, eva: callable) -> np.ndarray:
    objs = np.zeros((n_ins, 2))

    for i in range(n_ins):
        obj = solve_with_time(instance_data[i], eva)
        # print(f'{obj[0]}, {obj[1]}')
        objs[i] = np.array(obj)

    obj = np.mean(objs, axis=0)
    return -obj


class TSP_GLS_2O_Evaluation(Evaluation):
    """Evaluator for traveling salesman problem."""

    def __init__(self, **kwargs):

        """
            Args:
                None
            Raises:
                AttributeError: If the data key does not exist.
                FileNotFoundError: If the specified data file is not found.
        """

        super().__init__(
            template_program=template_program,
            task_description=task_description,
            use_numba_accelerate=False,
            timeout_seconds=20
        )

        self.n_instance = 16
        self.problem_size = 100
        getData = GetData(self.n_instance, self.problem_size)
        self._datasets = getData.generate_instances()

    def evaluate_program(self, program_str: str, callable_func: callable) -> Any | None:
        return evaluate(self._datasets,self.n_instance,self.problem_size, callable_func)
    

if __name__ == '__main__':
    import numpy as np


    def update_edge_distance(edge_distance: np.ndarray, local_opt_tour: np.ndarray,
                             edge_n_used: np.ndarray) -> np.ndarray:
        """
        Design a novel algorithm to update the distance matrix.

        Args:
        edge_distance: A matrix of the distance.
        local_opt_tour: An array of the local optimal tour of IDs.
        edge_n_used: A matrix of the number of each edge used during permutation.

        Return:
        updated_edge_distance: A matrix of the updated distance.
        """
        updated_edge_distance = np.copy(edge_distance)

        # Calculate combined importance and frequency factor
        combined_factor = (1 / edge_n_used) + (1 / edge_n_used)

        for i in range(len(local_opt_tour) - 1):
            node1 = local_opt_tour[i]
            node2 = local_opt_tour[i + 1]

            update_factor = combined_factor[node1, node2]

            updated_edge_distance[node1, node2] += update_factor
            updated_edge_distance[node2, node1] = updated_edge_distance[node1, node2]

        return updated_edge_distance
    
    tsp = TSP_GLS_2O_Evaluation()
    tsp.evaluate_program('_', update_edge_distance)

# Task configuration for benchmark task
ENTRY_NAME = 'update_edge_distance'
FUNCTION_SIGNATURE = 'def update_edge_distance(...):'
IMPORT_HEADER = 'import numpy as np\nimport math'
TASK_DESCRIPTION = 'Given an edge distance matrix and a local optimal route, please help me design a strategy to update the distance matrix to avoid being trapped in the local optimum with the final goal of finding a tour with minimized distance. You should create a heuristic for me to update the edge distance matrix.'
OBJECTIVE_TEXT = 'You are optimizing the implementation of `update_edge_distance` for the LLM4AD task.\\n\\nTask description:\\nGiven an edge distance matrix and a local optimal route, please help me design a strategy to update the distance matrix to avoid being trapped in the local optimum with the final goal of finding a tour with minimized distance. You should create a heuristic for me to update the edge distance matrix.\\n\\nYour goal is to return a correct and efficient function whose score (computed by the task evaluator) is as high as possible.'
TEMPLATE_FUNCTION = 'import numpy as np\ndef update_edge_distance(edge_distance: np.ndarray, local_opt_tour: np.ndarray, edge_n_used: np.ndarray) -> np.ndarray:\n    """\n    Design a novel algorithm to update the distance matrix.\n\n    Args:\n    edge_distance: A matrix of the distance.\n    local_opt_tour: An array of the local optimal tour of IDs.\n    edge_n_used: A matrix of the number of each edge used during permutation.\n\n    Return:\n    updated_edge_distance: A matrix of the updated distance.\n    """\n    updated_edge_distance = np.copy(edge_distance)\n\n    # Calculate combined importance and frequency factor\n    combined_factor = (1 / edge_n_used) + (1 / edge_n_used)\n\n    for i in range(len(local_opt_tour) - 1):\n        node1 = local_opt_tour[i]\n        node2 = local_opt_tour[i + 1]\n\n        update_factor = combined_factor[node1, node2]\n\n        updated_edge_distance[node1, node2] += update_factor\n        updated_edge_distance[node2, node1] = updated_edge_distance[node1, node2]\n\n    return updated_edge_distance'
EVAL_CLASS_NAME = 'TSP_GLS_2O_Evaluation'
EVAL_KWARGS = {'timeout_seconds': 60}

def build_trace_problem(**override_eval_kwargs) -> dict:
    """Build a Trace-ready problem using embedded benchmark evaluator."""
    
    # Create evaluator instance with embedded class
    eval_kwargs_final = EVAL_KWARGS.copy()
    eval_kwargs_final.update(override_eval_kwargs)
    
    evaluator = globals()[EVAL_CLASS_NAME](**eval_kwargs_final)
    
    from llm4ad_loader import AutonomousEvaluatorGuide
    from opto import trace
    
    # Create parameter
    initial_code = TEMPLATE_FUNCTION.strip()
    param = trace.node(initial_code, name='__code', 
                      description=f'The code should start with: {FUNCTION_SIGNATURE}', 
                      trainable=True)
    
    # Create guide using benchmark embedded evaluator
    guide = AutonomousEvaluatorGuide(evaluator, ENTRY_NAME, IMPORT_HEADER, 
                                   timeout=eval_kwargs_final.get('timeout_seconds', 30))
    
    # Create dataset
    train_dataset = dict(
        inputs=[TASK_DESCRIPTION],
        infos=[{'imports': IMPORT_HEADER, 'entry': ENTRY_NAME}]
    )
    
    # Optimizer kwargs
    optimizer_kwargs = dict(
        objective=OBJECTIVE_TEXT,
        memory_size=10
    )
    
    return dict(
        param=param,
        guide=guide,
        train_dataset=train_dataset,
        optimizer_kwargs=optimizer_kwargs,
        metadata=dict(
            entry=ENTRY_NAME,
            function_signature=FUNCTION_SIGNATURE,
            eval_class=EVAL_CLASS_NAME,
            benchmark=True,
        )
    )
