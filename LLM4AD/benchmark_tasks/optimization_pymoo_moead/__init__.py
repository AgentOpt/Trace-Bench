#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Autonomous LLM4AD task: optimization_pymoo_moead
Generated by convert_llm4ad_benchmark.py

This is a fully self-contained task module that doesn't depend on the original LLM4AD codebase.
"""

# Embedded evaluation code (benchmark)
# Module Name: MOEAD_PYMOO_Evaluation
# Last Revision: 2025/07/14
# Description: Evaluates the Multi-objective problem using the MOEAD algorithm.
#              Problem instances are generated by the GetData class.
#
# Parameters:
#    - timeout_seconds: Maximum allowed time (in seconds) for the evaluation process: int (default: 20).
#    - n_var: The number of decision variables for the optimization problem: int (default: 10).
#    - n_obj: The number of objectives for the optimization problem: int (default: 3).
#    - n_partitions: The number of partitions used to generate reference directions: int (default: 12).
#    - pop_size: The size of the population in the evolutionary algorithm: int (default: 100).
#    - n_gen: The number of generations for the algorithm to run: int (default: 100).
#
# References:
#   - Fei Liu, Rui Zhang, Zhuoliang Xie, Rui Sun, Kai Li, Xi Lin, Zhenkun Wang,
#       Zhichao Lu, and Qingfu Zhang, "LLM4AD: A Platform for Algorithm Design
#       with Large Language Model," arXiv preprint arXiv:2412.17287 (2024).
#
# ------------------------------- Copyright --------------------------------
# Copyright (c) 2025 Optima Group.
#
# Permission is granted to use the LLM4AD platform for research purposes.
# All publications, software, or other works that utilize this platform
# or any part of its codebase must acknowledge the use of "LLM4AD" and
# cite the following reference:
#
# Fei Liu, Rui Zhang, Zhuoliang Xie, Rui Sun, Kai Li, Xi Lin, Zhenkun Wang,
# Zhichao Lu, and Qingfu Zhang, "LLM4AD: A Platform for Algorithm Design
# with Large Language Model," arXiv preprint arXiv:2412.17287 (2024).
#
# For inquiries regarding commercial use or licensing, please contact
# http://www.llm4ad.com/contact.html
# --------------------------------------------------------------------------

from __future__ import annotations

import os, sys
sys.path.insert(0, os.path.dirname(__file__))
import copy
from typing import Callable, Any
import numpy as np

from pymoo.algorithms.moo.moead import MOEAD
from pymoo.indicators.hv import HV
from pymoo.optimize import minimize
from pymoo.termination import get_termination
from pymoo.util.ref_dirs import get_reference_directions
from pymoo.decomposition.tchebicheff import Tchebicheff

from llm4ad_loader import Evaluation
# Assuming the new GetData class is located at the following path
from get_instance import GetData
# from llm4ad.task.optimization.pymoo_moead.get_instance import GetData  # Converted from LLM4AD import
# from llm4ad.task.optimization.pymoo_moead.template import template_program, task_description  # Template values embedded below

# Embedded template values
template_program = 'import numpy as np\n\ndef custom_decomposition(F: np.ndarray,\n                         weights: np.ndarray,\n                         ideal_point: np.ndarray,\n                         **kwargs) -> np.ndarray:\n    """Design a novel decomposition method for MOEA/D.\n\n    Args:\n        F (np.ndarray): A set of objective vectors for the population.\n                        Shape: (n_solutions, n_objectives)\n        weights (np.ndarray): The weight vectors for the subproblems.\n                              Shape: (n_solutions, n_objectives)\n        ideal_point (np.ndarray): The ideal point found so far.\n                                  Shape: (n_objectives,)\n\n    Returns:\n        np.ndarray: The aggregated scalar value for each solution.\n                    Shape: (n_solutions,)\n    """\n    # Default implementation: Tchebycheff decomposition.\n    # Replace this with your novel algorithm.\n    v = np.abs(F - ideal_point) * weights\n    return np.max(v, axis=1)'
task_description = '"'


class MOEAD_PYMOO_Evaluation(Evaluation):
    def __init__(self,
                 timeout_seconds=100,
                 n_var=10,
                 n_obj=3,
                 n_partitions=12,
                 pop_size=100,
                 n_gen=100,
                 seed=None,
                 **kwargs):
        """
        Parameter Description:
        This evaluator now receives a decomposition function via the evaluate_program interface.
        """
        super().__init__(
            template_program=template_program,
            task_description=task_description,
            use_numba_accelerate=False,
            timeout_seconds=timeout_seconds
        )

        # Following the CVRP pattern, use the GetData class to generate problem instances
        getData = GetData(n_var=n_var, n_obj=n_obj)
        self.problem = getData.get_problem_instance()

        self.ref_dirs = get_reference_directions("das-dennis", self.problem.n_obj, n_partitions=n_partitions)
        self.pop_size = pop_size if pop_size else len(self.ref_dirs)
        self.n_gen = n_gen
        self.seed = seed
        self.hv_ref = np.array([1.1] * self.problem.n_obj)
        self.hv_calculator = HV(ref_point=self.hv_ref)
        self.last_result = None


    def evaluate(self, decomposition_func: Callable = None) -> float:
        """
        Core evaluation method. Returns the evaluation score and stores detailed results in self.last_result.
        """
        class DecompAdapter:
            def __init__(self, func):
                self.func = func
            def do(self, F, weights, ideal_point, **kwargs):
                return self.func(F, weights=weights, ideal_point=ideal_point, **kwargs)

        decomposition = DecompAdapter(decomposition_func) if decomposition_func else Tchebicheff()

        algorithm = MOEAD(
            ref_dirs=self.ref_dirs,
            n_neighbors=15,
            prob_neighbor_mating=0.7,
            decomposition=decomposition,
            seed=self.seed
        )

        termination = get_termination("n_gen", self.n_gen)
        res = minimize(self.problem, algorithm, termination, seed=self.seed, verbose=False)

        hv_value = self.hv_calculator(res.opt.get("F"))
        self.last_result = {"hv": hv_value, "pareto_front": res.opt}
        return -hv_value


    def evaluate_program(self, program_str: str, callable_func: callable) -> Any:
        return self.evaluate(decomposition_func=callable_func)

    def plot_solutions(self, solutions):
        import matplotlib.pyplot as plt
        F = solutions.get("F")
        fig = plt.figure(figsize=(10, 8))
        ax = fig.add_subplot(111, projection='3d')
        ax.scatter(F[:, 0], F[:, 1], F[:, 2], c='blue', s=30, alpha=0.5)
        ax.set_xlabel('Objective 1'); ax.set_ylabel('Objective 2'); ax.set_zlabel('Objective 3')
        ax.set_title(f'MOEAD on {self.problem.__class__.__name__} (HV = {self.hv_calculator(F):.4f})')
        plt.tight_layout(); plt.show()

if __name__ == "__main__":
    def custom_decomposition_tchebycheff(F: np.ndarray, weights: np.ndarray, ideal_point: np.ndarray, **kwargs) -> np.ndarray:
        v = np.abs(F - ideal_point) * weights
        return np.max(v, axis=1)

    evaluator = MOEAD_PYMOO_Evaluation(n_gen=100, seed=1)
    score = evaluator.evaluate_program("", custom_decomposition_tchebycheff)
    results = evaluator.last_result

    print(f"Evaluation Score (Negative HV): {score:.5f}")
    print(f"Hypervolume (HV): {results['hv']:.4f}")

    if evaluator.problem.n_obj == 3 and results:
        evaluator.plot_solutions(results["pareto_front"])

# Task configuration for benchmark task
ENTRY_NAME = 'custom_decomposition'
FUNCTION_SIGNATURE = 'def custom_decomposition(...):'
IMPORT_HEADER = 'import numpy as np\nimport math'
TASK_DESCRIPTION = '"'
OBJECTIVE_TEXT = 'You are optimizing the implementation of `custom_decomposition` for the LLM4AD task.\\n\\nTask description:\\n"\\n\\nYour goal is to return a correct and efficient function whose score (computed by the task evaluator) is as high as possible.'
TEMPLATE_FUNCTION = 'import numpy as np\n\ndef custom_decomposition(F: np.ndarray,\n                         weights: np.ndarray,\n                         ideal_point: np.ndarray,\n                         **kwargs) -> np.ndarray:\n    """Design a novel decomposition method for MOEA/D.\n\n    Args:\n        F (np.ndarray): A set of objective vectors for the population.\n                        Shape: (n_solutions, n_objectives)\n        weights (np.ndarray): The weight vectors for the subproblems.\n                              Shape: (n_solutions, n_objectives)\n        ideal_point (np.ndarray): The ideal point found so far.\n                                  Shape: (n_objectives,)\n\n    Returns:\n        np.ndarray: The aggregated scalar value for each solution.\n                    Shape: (n_solutions,)\n    """\n    # Default implementation: Tchebycheff decomposition.\n    # Replace this with your novel algorithm.\n    v = np.abs(F - ideal_point) * weights\n    return np.max(v, axis=1)'
EVAL_CLASS_NAME = 'MOEAD_PYMOO_Evaluation'
EVAL_KWARGS = {'timeout_seconds': 100}

def build_trace_problem(**override_eval_kwargs) -> dict:
    """Build a Trace-ready problem using embedded benchmark evaluator."""
    
    # Create evaluator instance with embedded class
    eval_kwargs_final = EVAL_KWARGS.copy()
    eval_kwargs_final.update(override_eval_kwargs)
    
    evaluator = globals()[EVAL_CLASS_NAME](**eval_kwargs_final)
    
    from llm4ad_loader import AutonomousEvaluatorGuide
    from opto import trace
    
    # Create parameter
    initial_code = TEMPLATE_FUNCTION.strip()
    param = trace.node(initial_code, name='__code', 
                      description=f'The code should start with: {FUNCTION_SIGNATURE}', 
                      trainable=True)
    
    # Create guide using benchmark embedded evaluator
    guide = AutonomousEvaluatorGuide(evaluator, ENTRY_NAME, IMPORT_HEADER, 
                                   timeout=eval_kwargs_final.get('timeout_seconds', 30))
    
    # Create dataset
    train_dataset = dict(
        inputs=[TASK_DESCRIPTION],
        infos=[{'imports': IMPORT_HEADER, 'entry': ENTRY_NAME}]
    )
    
    # Optimizer kwargs
    optimizer_kwargs = dict(
        objective=OBJECTIVE_TEXT,
        memory_size=10
    )
    
    return dict(
        param=param,
        guide=guide,
        train_dataset=train_dataset,
        optimizer_kwargs=optimizer_kwargs,
        metadata=dict(
            entry=ENTRY_NAME,
            function_signature=FUNCTION_SIGNATURE,
            eval_class=EVAL_CLASS_NAME,
            benchmark=True,
        )
    )
