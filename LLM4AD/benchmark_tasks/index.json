[
  {
    "key": "circle_packing",
    "module": "circle_packing",
    "entry": "pack_circles",
    "eval_class": "CirclePackingEvaluation",
    "task_description": "Implement a function that uses a constructive heuristic to pack n non-overlapping circles iteratively within a unit square to maximize the sum of their radii",
    "wrapper": "circle_packing",
    "copied_files": [
      "run_eoh.py"
    ],
    "benchmark": true
  },
  {
    "key": "online_bin_packing_local",
    "module": "online_bin_packing_local",
    "entry": "priority",
    "eval_class": "OBPEvaluation",
    "task_description": "Implement a function that returns the priority with which we want to add an item to each bin.",
    "wrapper": "online_bin_packing_local",
    "copied_files": [
      "run_eoh.py",
      "generate_weibull_instances.py"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/tsp_gls_2O",
    "module": "optimization_tsp_gls_2O",
    "entry": "update_edge_distance",
    "eval_class": "TSP_GLS_2O_Evaluation",
    "task_description": "Given an edge distance matrix and a local optimal route, please help me design a strategy to update the distance matrix to avoid being trapped in the local optimum with the final goal of finding a tour with minimized distance. You should create a heuristic for me to update the edge distance matrix.",
    "wrapper": "optimization_tsp_gls_2O",
    "copied_files": [
      "get_instance.py",
      "__init__.py",
      "gls.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/set_cover_construct",
    "module": "optimization_set_cover_construct",
    "entry": "select_next_subset",
    "eval_class": "SCPEvaluation",
    "task_description": "'",
    "wrapper": "optimization_set_cover_construct",
    "copied_files": [
      "get_instance.py",
      "test.py",
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/tsp_construct",
    "module": "optimization_tsp_construct",
    "entry": "select_next_node",
    "eval_class": "TSPEvaluation",
    "task_description": "\"Given a set of nodes with their coordinates, you need to find the shortest route that visits each node once and returns to the starting node. \\",
    "wrapper": "optimization_tsp_construct",
    "copied_files": [
      "get_instance.py",
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/bp_2d_construct",
    "module": "optimization_bp_2d_construct",
    "entry": "determine_next_assignment",
    "eval_class": "BP2DEvaluation",
    "task_description": "'",
    "wrapper": "optimization_bp_2d_construct",
    "copied_files": [
      "get_instance.py",
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/online_bin_packing_2O",
    "module": "optimization_online_bin_packing_2O",
    "entry": "priority",
    "eval_class": "OBP_2O_Evaluation",
    "task_description": "Implement a function that returns the priority with which we want to add an item to each bin.",
    "wrapper": "optimization_online_bin_packing_2O",
    "copied_files": [
      "__init__.py",
      "generate_weibull_instances.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/cflp_construct",
    "module": "optimization_cflp_construct",
    "entry": "select_next_assignment",
    "eval_class": "CFLPEvaluation",
    "task_description": "'",
    "wrapper": "optimization_cflp_construct",
    "copied_files": [
      "get_instance.py",
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/vrptw_construct",
    "module": "optimization_vrptw_construct",
    "entry": "select_next_node",
    "eval_class": "VRPTWEvaluation",
    "task_description": "The task involves finding optimal routes for a fleet of vehicles to serve a set of customers, respecting time windows and vehicle capacity constraints. Help me design an algorithm to select the next node in each step.",
    "wrapper": "optimization_vrptw_construct",
    "copied_files": [
      "get_instance.py",
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/online_bin_packing",
    "module": "optimization_online_bin_packing",
    "entry": "priority",
    "eval_class": "OBPEvaluation",
    "task_description": "Implement a function that returns the priority with which we want to add an item to each bin.",
    "wrapper": "optimization_online_bin_packing",
    "copied_files": [
      "__init__.py",
      "generate_weibull_instances.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/knapsack_construct",
    "module": "optimization_knapsack_construct",
    "entry": "select_next_item",
    "eval_class": "KnapsackEvaluation",
    "task_description": "'",
    "wrapper": "optimization_knapsack_construct",
    "copied_files": [
      "get_instance.py",
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/pymoo_moead",
    "module": "optimization_pymoo_moead",
    "entry": "custom_decomposition",
    "eval_class": "MOEAD_PYMOO_Evaluation",
    "task_description": "\"",
    "wrapper": "optimization_pymoo_moead",
    "copied_files": [
      "get_instance.py",
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/cvrp_construct",
    "module": "optimization_cvrp_construct",
    "entry": "select_next_node",
    "eval_class": "CVRPEvaluation",
    "task_description": "\"",
    "wrapper": "optimization_cvrp_construct",
    "copied_files": [
      "get_instance.py",
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/jssp_construct",
    "module": "optimization_jssp_construct",
    "entry": "determine_next_operation",
    "eval_class": "JSSPEvaluation",
    "task_description": "'",
    "wrapper": "optimization_jssp_construct",
    "copied_files": [
      "get_instance.py",
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/bp_1d_construct",
    "module": "optimization_bp_1d_construct",
    "entry": "determine_next_assignment",
    "eval_class": "BP1DEvaluation",
    "task_description": "'",
    "wrapper": "optimization_bp_1d_construct",
    "copied_files": [
      "get_instance.py",
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/admissible_set",
    "module": "optimization_admissible_set",
    "entry": "priority",
    "eval_class": "ASPEvaluation",
    "task_description": "\"\"\"\\",
    "wrapper": "optimization_admissible_set",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/qap_construct",
    "module": "optimization_qap_construct",
    "entry": "select_next_assignment",
    "eval_class": "QAPEvaluation",
    "task_description": "'",
    "wrapper": "optimization_qap_construct",
    "copied_files": [
      "get_instance.py",
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/ovrp_construct",
    "module": "optimization_ovrp_construct",
    "entry": "select_next_node",
    "eval_class": "OVRPEvaluation",
    "task_description": "\"",
    "wrapper": "optimization_ovrp_construct",
    "copied_files": [
      "get_instance.py",
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/open_shop_scheduling_co_bench",
    "module": "optimization_open_shop_scheduling",
    "entry": "solve",
    "eval_class": "OSSEvaluationCB",
    "task_description": "(\"The Open Shop Scheduling Problem involves scheduling a set of jobs across a set of machines with \"",
    "wrapper": "optimization_open_shop_scheduling",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/generalised_assignment_problem_co_bench",
    "module": "optimization_generalised_assignment_problem",
    "entry": "solve",
    "eval_class": "GAPEvaluationCB",
    "task_description": "(\"The Generalized Assignment Problem (GAP) involves assigning \\( n \\) jobs to \\( m \\) agents such \"",
    "wrapper": "optimization_generalised_assignment_problem",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/flow_shop_scheduling_co_bench",
    "module": "optimization_flow_shop_scheduling",
    "entry": "solve",
    "eval_class": "FSSEvaluationCB",
    "task_description": "(\"Given  n  jobs and  m  machines, the goal of the flow shop scheduling problem is to determine \"",
    "wrapper": "optimization_flow_shop_scheduling",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/set_partitioning_co_bench",
    "module": "optimization_set_partitioning",
    "entry": "solve",
    "eval_class": "SPEvaluationCB",
    "task_description": "(\"This problem involves solving a set partitioning instance where the goal is to choose a subset \"",
    "wrapper": "optimization_set_partitioning",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/maximal_independent_set_co_bench",
    "module": "optimization_maximal_independent_set",
    "entry": "solve",
    "eval_class": "MISEvaluationCB",
    "task_description": "(\"The Maximum Independent Set (MIS) problem is a fundamental NP-hard optimization problem in graph \"",
    "wrapper": "optimization_maximal_independent_set",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/container_loading_co_bench",
    "module": "optimization_container_loading",
    "entry": "solve",
    "eval_class": "CLEvaluationCB",
    "task_description": "(\"Solves a container loading problem: Given a 3D container of specified dimensions and multiple \"",
    "wrapper": "optimization_container_loading",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/equitable_partitioning_problem_co_bench",
    "module": "optimization_equitable_partitioning_problem",
    "entry": "solve",
    "eval_class": "EPPEvaluationCB",
    "task_description": "(\"The task is to partition a set of individuals\u2014each characterized by multiple binary \"",
    "wrapper": "optimization_equitable_partitioning_problem",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/p_median_uncapacitated_co_bench",
    "module": "optimization_p_median_uncapacitated",
    "entry": "solve",
    "eval_class": "PMUEvaluationCB",
    "task_description": "(\"The uncapacitated p-median problem is a combinatorial optimization problem defined on a given \"",
    "wrapper": "optimization_p_median_uncapacitated",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/crew_scheduling_co_bench",
    "module": "optimization_crew_scheduling",
    "entry": "solve",
    "eval_class": "CSchedulingEvaluationCB",
    "task_description": "(\"The Crew Scheduling Problem involves assigning each task\u2014with defined start and finish times\u2014to \"",
    "wrapper": "optimization_crew_scheduling",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/euclidean_steiner_problem_co_bench",
    "module": "optimization_euclidean_steiner_problem",
    "entry": "solve",
    "eval_class": "ESPEvaluationCB",
    "task_description": "(\"Given a set of 2D points (terminals), the goal of the Euclidean Steiner Problem is to compute a \"",
    "wrapper": "optimization_euclidean_steiner_problem",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/unconstrained_guillotine_cutting_co_bench",
    "module": "optimization_unconstrained_guillotine_cutting",
    "entry": "solve",
    "eval_class": "UGCEvaluationCB",
    "task_description": "(\"The unconstrained guillotine cutting problem involves selecting and placing a subset of \"",
    "wrapper": "optimization_unconstrained_guillotine_cutting",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/packing_unequal_circles_co_bench",
    "module": "optimization_packing_unequal_circles",
    "entry": "solve",
    "eval_class": "PUCEvaluationCB",
    "task_description": "(\"The problem involves packing a subset of unequal circles into a fixed circular container with \"",
    "wrapper": "optimization_packing_unequal_circles",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/packing_unequal_rectangles_and_squares_area_co_bench",
    "module": "optimization_packing_unequal_rectangles_and_squares_area",
    "entry": "solve",
    "eval_class": "PURSAEvaluationCB",
    "task_description": "(\"We consider the problem of selecting and placing a subset of  n  unequal rectangles (or squares) \"",
    "wrapper": "optimization_packing_unequal_rectangles_and_squares_area",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/hybrid_reentrant_shop_scheduling_co_bench",
    "module": "optimization_hybrid_reentrant_shop_scheduling",
    "entry": "solve",
    "eval_class": "HRSSEvaluationCB",
    "task_description": "(\"The problem is a Hybrid Reentrant Shop Scheduling problem where each of n jobs must sequentially \"",
    "wrapper": "optimization_hybrid_reentrant_shop_scheduling",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/travelling_salesman_problem_co_bench",
    "module": "optimization_travelling_salesman_problem",
    "entry": "solve",
    "eval_class": "TSPEvaluationCB",
    "task_description": "(\"The Traveling Salesman Problem (TSP) is a classic combinatorial optimization problem where, \"",
    "wrapper": "optimization_travelling_salesman_problem",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/uncapacitated_warehouse_location_co_bench",
    "module": "optimization_uncapacitated_warehouse_location",
    "entry": "solve",
    "eval_class": "UWLEvaluationCB",
    "task_description": "(\"The Uncapacitated Warehouse Location Problem aims to determine which warehouses to open and how \"",
    "wrapper": "optimization_uncapacitated_warehouse_location",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/bp_1d_co_bench",
    "module": "optimization_bp_1d",
    "entry": "solve",
    "eval_class": "BP1DEvaluationCB",
    "task_description": "(\"The **one-dimensional bin packing problem** seeks to minimize the number of bins required to \"",
    "wrapper": "optimization_bp_1d",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/job_shop_scheduling_co_bench",
    "module": "optimization_job_shop_scheduling",
    "entry": "solve",
    "eval_class": "JSSEvaluationCB",
    "task_description": "(\"The job shop scheduling problem requires assigning non-negative integer start times to a set of \"",
    "wrapper": "optimization_job_shop_scheduling",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/corporate_structuring_co_bench",
    "module": "optimization_corporate_structuring",
    "entry": "solve",
    "eval_class": "CSEvaluationCB",
    "task_description": "'''Given N countries, each defined by:",
    "wrapper": "optimization_corporate_structuring",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/assignment_problem_co_bench",
    "module": "optimization_assignment_problem",
    "entry": "solve",
    "eval_class": "APEvaluationCB",
    "task_description": "(\"The Assignment Problem involves optimally assigning  n  items to  n  agents based on a provided  \"",
    "wrapper": "optimization_assignment_problem",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/packing_unequal_rectangles_and_squares_co_bench",
    "module": "optimization_packing_unequal_rectangles_and_squares",
    "entry": "solve",
    "eval_class": "PURSEvaluationCB",
    "task_description": "(\"We are given a set of n unequal rectangles (or squares), each with specified dimensions, \"",
    "wrapper": "optimization_packing_unequal_rectangles_and_squares",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/assortment_problem_co_bench",
    "module": "optimization_assortment_problem",
    "entry": "solve",
    "eval_class": "AssortPEvaluationCB",
    "task_description": "(\"This optimization problem involves arranging a set of rectangular pieces within available stock \"",
    "wrapper": "optimization_assortment_problem",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/set_covering_co_bench",
    "module": "optimization_set_covering",
    "entry": "solve",
    "eval_class": "SCEvaluationCB",
    "task_description": "(\"Set Covering Problem. The goal is to select a subset of columns, each with an associated cost, \"",
    "wrapper": "optimization_set_covering",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/p_median_capacitated_co_bench",
    "module": "optimization_p_median_capacitated",
    "entry": "solve",
    "eval_class": "PMCEvaluationCB",
    "task_description": "(\"The Capacitated P-Median Problem is a facility location optimization problem where the objective \"",
    "wrapper": "optimization_p_median_capacitated",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/multi_demand_multidimensional_knapsack_problem_co_bench",
    "module": "optimization_multi_demand_multidimensional_knapsack_problem",
    "entry": "solve",
    "eval_class": "MDMKPEvaluationCB",
    "task_description": "(\"The Multi-Demand Multidimensional Knapsack Problem (MDMKP) is a binary optimization problem that \"",
    "wrapper": "optimization_multi_demand_multidimensional_knapsack_problem",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/container_loading_with_weight_restrictions_co_bench",
    "module": "optimization_container_loading_with_weight_restrictions",
    "entry": "solve",
    "eval_class": "CLWREvaluationCB",
    "task_description": "(\"The Container Loading with Weight Restrictions problem aims to maximize the utilization of a \"",
    "wrapper": "optimization_container_loading_with_weight_restrictions",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/capacitated_warehouse_location_co_bench",
    "module": "optimization_capacitated_warehouse_location",
    "entry": "solve",
    "eval_class": "CWLEvaluationCB",
    "task_description": "(\"The Capacitated Warehouse Location Problem with Splittable Demand aims to determine which \"",
    "wrapper": "optimization_capacitated_warehouse_location",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/common_due_date_scheduling_co_bench",
    "module": "optimization_common_due_date_scheduling",
    "entry": "solve",
    "eval_class": "CDDSEvaluationCB",
    "task_description": "(\"The **Restricted Single-Machine Common Due Date Scheduling Problem** involves scheduling a set \"",
    "wrapper": "optimization_common_due_date_scheduling",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/constrained_guillotine_cutting_co_bench",
    "module": "optimization_constrained_guillotine_cutting",
    "entry": "solve",
    "eval_class": "CGCEvaluationCB",
    "task_description": "(\"The problem involves optimizing the guillotine feasible placement of a set of rectangular pieces \"",
    "wrapper": "optimization_constrained_guillotine_cutting",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/packing_unequal_circles_area_co_bench",
    "module": "optimization_packing_unequal_circles_area",
    "entry": "solve",
    "eval_class": "PUCAEvaluationCB",
    "task_description": "(\"The problem involves packing a subset of unequal circles into a fixed circular container with \"",
    "wrapper": "optimization_packing_unequal_circles_area",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/graph_colouring_co_bench",
    "module": "optimization_graph_colouring",
    "entry": "solve",
    "eval_class": "GCEvaluationCB",
    "task_description": "(\"Given a graph in DIMACS format with vertices, edges, and an adjacency list, the goal is to \"",
    "wrapper": "optimization_graph_colouring",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/vehicle_routing_period_routing_co_bench",
    "module": "optimization_vehicle_routing_period_routing",
    "entry": "solve",
    "eval_class": "VRPREvaluationCB",
    "task_description": "(\"The Period Vehicle Routing Problem requires planning delivery routes over a multi\u2010day planning \"",
    "wrapper": "optimization_vehicle_routing_period_routing",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/resource_constrained_shortest_path_co_bench",
    "module": "optimization_resource_constrained_shortest_path",
    "entry": "solve",
    "eval_class": "RCSPEvaluationCB",
    "task_description": "(\"This problem involves finding the shortest path from vertex 1 to vertex n in a directed graph \"",
    "wrapper": "optimization_resource_constrained_shortest_path",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/multidimensional_knapsack_problem_co_bench",
    "module": "optimization_multidimensional_knapsack_problem",
    "entry": "solve",
    "eval_class": "MKPEvaluationCB",
    "task_description": "(\"This problem is a multidimensional knapsack optimization where the objective is to maximize the \"",
    "wrapper": "optimization_multidimensional_knapsack_problem",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/aircraft_landing_co_bench",
    "module": "optimization_aircraft_landing",
    "entry": "solve",
    "eval_class": "ALEvaluationCB",
    "task_description": "(\"The problem is to schedule landing times for a set of planes across one or more runways such that \"",
    "wrapper": "optimization_aircraft_landing",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "optimization/co_bench/constrained_non_guillotine_cutting_co_bench",
    "module": "optimization_constrained_non_guillotine_cutting",
    "entry": "solve",
    "eval_class": "CNCEvaluationCB",
    "task_description": "(\"The constrained non-guillotine cutting problem involves optimally arranging rectangular pieces \"",
    "wrapper": "optimization_constrained_non_guillotine_cutting",
    "copied_files": [
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "science_discovery/bactgrow",
    "module": "science_discovery_bactgrow",
    "entry": "equation",
    "eval_class": "BGEvaluation",
    "task_description": "(\"Find the mathematical function skeleton that represents E. Coli bacterial growth rate, \"",
    "wrapper": "science_discovery_bactgrow",
    "copied_files": [
      "test_id.py",
      "train.py",
      "test_odd.py",
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "science_discovery/stresstrain",
    "module": "science_discovery_stresstrain",
    "entry": "equation",
    "eval_class": "SSEvaluation",
    "task_description": "(\"Find the mathematical function skeleton that represents stress, given data on strain and \"",
    "wrapper": "science_discovery_stresstrain",
    "copied_files": [
      "test_id.py",
      "train.py",
      "test_odd.py",
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "science_discovery/oscillator2",
    "module": "science_discovery_oscillator2",
    "entry": "equation",
    "eval_class": "OscillatorEvaluation2",
    "task_description": "(\"Find the mathematical function skeleton that represents acceleration in a damped nonlinear \"",
    "wrapper": "science_discovery_oscillator2",
    "copied_files": [
      "test_id.py",
      "train.py",
      "test_odd.py",
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "science_discovery/feynman_srsd",
    "module": "science_discovery_feynman_srsd",
    "entry": "equation",
    "eval_class": "FeynmanEvaluation",
    "task_description": "Find the mathematical function skeleton to fit a dataset, you don't have to use all the params.",
    "wrapper": "science_discovery_feynman_srsd",
    "copied_files": [
      "registry.py",
      "feynman_equations.py",
      "sampling.py",
      "base.py",
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "science_discovery/oscillator1",
    "module": "science_discovery_oscillator1",
    "entry": "equation",
    "eval_class": "OscillatorEvaluation1",
    "task_description": "(\"Find the mathematical function skeleton that represents acceleration in a damped nonlinear \"",
    "wrapper": "science_discovery_oscillator1",
    "copied_files": [
      "test_id.py",
      "train.py",
      "test_odd.py",
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "science_discovery/ode_1d",
    "module": "science_discovery_ode_1d",
    "entry": "equation",
    "eval_class": "ODEEvaluation",
    "task_description": "(\"Find the ODE mathematical function skeleton, given data on initial x. The function should be differentiable, continuous.\"",
    "wrapper": "science_discovery_ode_1d",
    "copied_files": [
      "strogatz_equations.py",
      "strogatz_extended.py",
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "machine_learning/pendulum",
    "module": "machine_learning_pendulum",
    "entry": "choose_action",
    "eval_class": "PendulumEvaluation",
    "task_description": "(\"Implement a novel control strategy for the inverted pendulum swing-up problem. The goal is to \"",
    "wrapper": "machine_learning_pendulum",
    "copied_files": [
      "test.py",
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "machine_learning/moon_lander",
    "module": "machine_learning_moon_lander",
    "entry": "choose_action",
    "eval_class": "MoonLanderEvaluation",
    "task_description": "(\"Implement a novel heuristic strategy heuristic strategy function that guides the \"",
    "wrapper": "machine_learning_moon_lander",
    "copied_files": [
      "test.py",
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "machine_learning/car_mountain_continue",
    "module": "machine_learning_car_mountain_continue",
    "entry": "choose_action",
    "eval_class": "CarMountainCEvaluation",
    "task_description": "(\"Implement a function that designing a novel strategy function that guide the car along an uneven \"",
    "wrapper": "machine_learning_car_mountain_continue",
    "copied_files": [
      "test.py",
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "machine_learning/acrobot",
    "module": "machine_learning_acrobot",
    "entry": "choose_action",
    "eval_class": "AcrobotEvaluation",
    "task_description": "(\"I need help designing an innovative heuristic strategy function to control an acrobot, aiming to \"",
    "wrapper": "machine_learning_acrobot",
    "copied_files": [
      "test.py",
      "__init__.py",
      "paras.yaml"
    ],
    "benchmark": true
  },
  {
    "key": "machine_learning/car_mountain",
    "module": "machine_learning_car_mountain",
    "entry": "choose_action",
    "eval_class": "CarMountainEvaluation",
    "task_description": "(\"Implement a function that designing a novel strategy function that guide the car along an uneven \"",
    "wrapper": "machine_learning_car_mountain",
    "copied_files": [
      "test.py",
      "__init__.py",
      "q-learning.py",
      "paras.yaml"
    ],
    "benchmark": true
  }
]